<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Pac-Citadel â€” Gravity & Worlds (Smooth Fullscreen)</title>
<style>
  html, body {
    margin:0; padding:0; overflow:hidden; background:#111; color:#fff; font-family: system-ui, sans-serif;
    height: 100%; width: 100%;
  }
  #ui {
    position: fixed;
    top: 5px; left: 50%; transform: translateX(-50%);
    z-index: 10;
    background: rgba(0,0,0,0.5);
    padding: 6px 12px;
    border-radius: 8px;
    font-size: 16px;
    user-select:none;
  }
  .badge {
    display:inline-block; padding:4px 10px; border-radius:6px; background:rgba(255,255,255,0.07); margin:0 8px;
  }
  #stats, #log {
    position: fixed;
    bottom: 5px; left: 50%; transform: translateX(-50%);
    max-width: 90vw;
    max-height: 110px;
    overflow-y: auto;
    background: rgba(0,0,0,0.5);
    padding: 6px 10px;
    border-radius: 8px;
    font-size: 14px;
    line-height: 1.2em;
    user-select:none;
    z-index: 10;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #000;
    image-rendering: pixelated;
    /* will be resized dynamically */
  }
</style>
</head>
<body>
<div id="ui">
  <span class="badge">World: <span id="worldLabel">A</span></span>
  <span class="badge">Gravity: <span id="gravLabel">Down</span></span>
  <span class="badge">Next flip in: <span id="gravTimer">--</span>s</span>
  <span class="badge">Tip: Press <strong>Space</strong> to swap worlds</span>
</div>
<canvas id="game"></canvas>
<div id="stats"></div>
<div id="log"></div>
<script>
const TILE = 24; // bigger tiles for fullscreen
const MAP_W = 25, MAP_H = 25;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const logEl = document.getElementById('log');
const worldLabel = document.getElementById('worldLabel');
const gravLabel = document.getElementById('gravLabel');
const gravTimerEl = document.getElementById('gravTimer');
const statsEl = document.getElementById('stats');

function log(msg){ 
  const d=document.createElement('div'); 
  d.textContent=msg; 
  logEl.prepend(d); 
  console.log(msg); 
}

// Responsive canvas sizing to fill window with integer multiples of TILE
function resizeCanvas() {
  let w = window.innerWidth;
  let h = window.innerHeight;
  // limit size to map size
  const maxW = MAP_W * TILE;
  const maxH = MAP_H * TILE;
  w = Math.min(w, maxW);
  h = Math.min(h, maxH);
  // fit canvas to window but keep whole tiles
  const tilesX = Math.floor(w / TILE);
  const tilesY = Math.floor(h / TILE);
  canvas.width = tilesX * TILE;
  canvas.height = tilesY * TILE;
  // calculate view radius for drawing around player
  VIEW_RADIUS_X = Math.floor(tilesX/2);
  VIEW_RADIUS_Y = Math.floor(tilesY/2);
}
window.addEventListener('resize', resizeCanvas);

let VIEW_RADIUS_X = 9;
let VIEW_RADIUS_Y = 9;

function rand(n){ return Math.floor(Math.random()*n); }

function generateBaseMap(){
  for(const w of ['A','B']){
    const m = Array.from({length:MAP_H},()=>Array(MAP_W).fill(1));
    for(let y=1;y<MAP_H-1;y++) for(let x=1;x<MAP_W-1;x++) m[y][x] = (Math.random()<0.78?0:1);
    for(let y=2;y<MAP_H-2;y+=2) for(let x=2;x<MAP_W-2;x+=2) m[y][x]=1;
    maps[w]=m;
  }
}

function placeEntities(){
  items=[]; enemies=[];
  player.x = 1; player.y = 1; player.coins = 0; player.hp = 10;
  for(const w of ['A','B']){
    // place coins on all floor tiles in this world
    for(let y=0; y<MAP_H; y++){
      for(let x=0; x<MAP_W; x++){
        if(maps[w][y][x] === 0){
          items.push({x,y,type:'coin',world:w});
        }
      }
    }
    // potions sparse random
    for(let i=0;i<10;i++){
      let px, py;
      do {
        px = rand(MAP_W);
        py = rand(MAP_H);
      } while(maps[w][py][px] === 1);
      items.push({x:px,y:py,type:'potion',world:w});
    }
  }
  // tutorial cluster in world A near player
  items.push({x:2,y:1,type:'coin',world:'A'});
  items.push({x:3,y:1,type:'potion',world:'A'});
  // enemies random but more in opposite world
  for(const w of ['A','B']){
    for(let i=0;i<8;i++){
      const x = 2 + rand(MAP_W-4), y = 2 + rand(MAP_H-4);
      if(maps[w][y][x]===0 && Math.random()<0.12) enemies.push({x,y,hp:2,world:w, px:x, py:y});
    }
  }
  enemies.push({x:4,y:1,hp:2,world:'B', px:4, py:1});
}

function inBounds(x,y){ return x>=0 && y>=0 && x<MAP_W && y<MAP_H; }

function tryPickup(x,y){
  for(let i=items.length-1;i>=0;i--){
    const it=items[i];
    if(it.x===x && it.y===y && it.world===world){
      if(it.type==='coin'){
        player.coins++; 
        log('Picked coin!');
      } else {
        player.hp = Math.min(player.hp+5, 12); 
        log('Used potion +5 HP');
      }
      items.splice(i,1);
    }
  }
}

// Try hit enemy at tile (x,y)
function tryHitEnemy(x,y){
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    if(e.x===x && e.y===y && e.world===world){
      e.hp -= 1;
      log('Hit enemy!');
      if(e.hp<=0){
        enemies.splice(i,1);
        log('Enemy defeated');
      }
      return true;
    }
  }
  for(const e of enemies){
    if(e.x===x && e.y===y && e.world!==world){
      player.hp -= 1;
      log('Touched a ghost from the other world! -1 HP');
    }
  }
  return false;
}

// Player position stored as floats for smooth movement
let playerPos = { x:1, y:1 };
let playerTarget = { x:1, y:1 };
const MOVE_SPEED = 8; // tiles per second

function movePlayer(dx,dy){
  if(sliding) return;
  const nx = playerTarget.x + dx;
  const ny = playerTarget.y + dy;
  if(!inBounds(nx,ny) || maps[world][Math.floor(ny)][Math.floor(nx)]===1) return;
  tryPickup(Math.floor(nx), Math.floor(ny));
  if(tryHitEnemy(Math.floor(nx), Math.floor(ny))) return;
  playerTarget.x = nx;
  playerTarget.y = ny;
}

function slideEntity(ent){
  // slide in gravity dir until hit wall
  let moved = false;
  while(true){
    let nx=ent.x, ny=ent.y;
    if(gravIndex===0) ny++; else if(gravIndex===1) nx--; else if(gravIndex===2) ny--; else nx++;
    if(!inBounds(nx,ny) || maps[ent.world || world][ny][nx]===1) break;
    ent.x = nx; ent.y = ny; moved = true;
    if(ent===player) tryPickup(ent.x,ent.y);
  }
  return moved;
}

function flipGravity(now){
  gravIndex = (gravIndex+1) % 4;
  lastGravFlip = now;
  gravLabel.textContent = gravDirs[gravIndex];
  log('Gravity flipped to ' + gravDirs[gravIndex]);
  sliding = true;
  slideEntity(player);
  for(const e of enemies) slideEntity(e);
  sliding = false;
}

// Swap worlds
function swapWorlds(){
  if(sliding) return;
  world = (world==='A') ? 'B' : 'A';
  worldLabel.textContent = world;
  log('Swapped to world ' + world);
}

let lastEnemyMove = performance.now();
const enemyMoveInterval = 700;

function updateEnemies(delta){
  const now = performance.now();
  if(now - lastEnemyMove < enemyMoveInterval) return;
  lastEnemyMove = now;
  for(const e of enemies){
    if(e.world !== world) continue;
    let dx = Math.sign(playerTarget.x - e.x);
    let dy = Math.sign(playerTarget.y - e.y);
    if(dx!==0 && inBounds(e.x+dx, e.y) && maps[e.world][e.y][e.x+dx]===0){
      e.x += dx;
    } else if(dy!==0 && inBounds(e.x, e.y+dy) && maps[e.world][e.y+dy][e.x]===0){
      e.y += dy;
    }
    if(e.x===Math.floor(playerTarget.x) && e.y===Math.floor(playerTarget.y)){
      player.hp -= 1;
      log('Enemy hit you! -1 HP');
    }
  }
}

// Smooth interpolation for player and enemies
function lerp(a,b,t){ return a+(b-a)*t; }

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // Center drawing coords
  const tilesX = canvas.width / TILE;
  const tilesY = canvas.height / TILE;
  const baseX = Math.floor(playerPos.x) - Math.floor(tilesX/2);
  const baseY = Math.floor(playerPos.y) - Math.floor(tilesY/2);

  // Draw maze tiles & items & enemies within viewport
  for(let vy=0; vy<tilesY; vy++){
    for(let vx=0; vx<tilesX; vx++){
      const tx = baseX + vx;
      const ty = baseY + vy;
      const sx = vx * TILE;
      const sy = vy * TILE;
      if(tx<0 || ty<0 || tx>=MAP_W || ty>=MAP_H){
        ctx.fillStyle = '#000';
        ctx.fillRect(sx,sy,TILE,TILE);
        continue;
      }
      const tile = maps[world][ty][tx];
      ctx.fillStyle = tile===1 ? '#2b2b2b' : '#101824';
      ctx.fillRect(sx,sy,TILE,TILE);

      // coins (items)
      for(const it of items){
        if(it.world===world && it.x===tx && it.y===ty && it.type==='coin'){
          // animate coin: small scale pulse
          const pulse = 0.15 * Math.sin(performance.now()/250 + (tx+ty)*3) + 1;
          const radius = TILE*0.2 * pulse;
          ctx.fillStyle = '#ffd700';
          ctx.beginPath();
          ctx.ellipse(sx + TILE/2, sy + TILE/2, radius, radius*0.75, 0, 0, Math.PI*2);
          ctx.fill();
        } else if(it.world===world && it.x===tx && it.y===ty && it.type==='potion'){
          ctx.fillStyle = '#ff6b6b';
          ctx.beginPath();
          ctx.moveTo(sx + TILE*0.3, sy + TILE*0.2);
          ctx.lineTo(sx + TILE*0.7, sy + TILE*0.2);
          ctx.lineTo(sx + TILE*0.7, sy + TILE*0.7);
          ctx.lineTo(sx + TILE*0.3, sy + TILE*0.7);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = '#ff3b3b';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      // enemies
      for(const e of enemies){
        if(e.x===tx && e.y===ty){
          if(e.world===world){
            // interpolate enemy pos for smoothness
            const ex = e.x - baseX;
            const ey = e.y - baseY;
            const px = lerp(e.px || e.x, e.x, 0.5);
            const py = lerp(e.py || e.y, e.y, 0.5);
            ctx.fillStyle = '#ff4d4d';
            ctx.beginPath();
            ctx.arc(sx + TILE/2, sy + TILE/2, TILE*0.38, Math.PI, 0);
            ctx.lineTo(sx + TILE*0.85, sy + TILE*0.9);
            ctx.lineTo(sx + TILE*0.15, sy + TILE*0.9);
            ctx.closePath();
            ctx.fill();
            // eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(sx + TILE*0.33, sy + TILE*0.5, TILE*0.12, 0, Math.PI*2);
            ctx.arc(sx + TILE*0.67, sy + TILE*0.5, TILE*0.12, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(sx + TILE*0.33, sy + TILE*0.52, TILE*0.06, 0, Math.PI*2);
            ctx.arc(sx + TILE*0.67, sy + TILE*0.52, TILE*0.06, 0, Math.PI*2);
            ctx.fill();
            // update previous pos for next frame
            e.px = e.x; e.py = e.y;
          } else {
            ctx.fillStyle = 'rgba(80,160,255,0.45)';
            ctx.fillRect(sx+3,sy+3,TILE-6,TILE-6);
            ctx.fillStyle='#aee';
            ctx.font='9px monospace';
            ctx.fillText('G', sx+TILE/2-3, sy+TILE/2+3);
          }
        }
      }
    }
  }
  // player smooth pos
  const px = (playerPos.x - baseX)*TILE;
  const py = (playerPos.y - baseY)*TILE;
  ctx.fillStyle = '#7dffb2';
  ctx.beginPath();
  ctx.arc(px + TILE/2, py + TILE/2, TILE*0.38, 0, Math.PI*2);
  ctx.fill();
  // mouth animation (classic Pacman chomping)
  const mouthOpen = 0.25 + 0.25 * Math.sin(performance.now() / 150);
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.moveTo(px + TILE/2, py + TILE/2);
  ctx.arc(px + TILE/2, py + TILE/2, TILE*0.38, mouthOpen * Math.PI, (2 - mouthOpen) * Math.PI);
  ctx.closePath();
  ctx.fill();
}

let lastFrame = performance.now();

function update(delta){
  // Smoothly move player towards target position
  const distX = playerTarget.x - playerPos.x;
  const distY = playerTarget.y - playerPos.y;
  const dist = Math.sqrt(distX*distX + distY*distY);
  if(dist > 0){
    const maxMove = MOVE_SPEED * delta;
    if(dist <= maxMove){
      playerPos.x = playerTarget.x;
      playerPos.y = playerTarget.y;
    } else {
      playerPos.x += (distX/dist)*maxMove;
      playerPos.y += (distY/dist)*maxMove;
    }
  }

  // Update enemies smoothly too
  for(const e of enemies){
    // interpolate enemy positions slowly to current tile pos for smoothness
    if(e.px === undefined) { e.px = e.x; e.py = e.y; }
    const edx = e.x - e.px;
    const edy = e.y - e.py;
    e.px += edx * Math.min(1, delta * 5);
    e.py += edy * Math.min(1, delta * 5);
  }
}

const gravDirs = ['Down','Left','Up','Right'];
let gravIndex = 0;
let gravFlipInterval = 12000;
let lastGravFlip = performance.now();
let sliding = false;

let world = 'A';
let maps = { A: [], B: [] };
let items = [];
let enemies = [];
let player = {x:1,y:1,hp:10,coins:0};

function loop(now){
  const delta = (now - lastFrame)/1000;
  lastFrame = now;

  // Gravity timer
  const untilFlip = Math.max(0, gravFlipInterval - (now - lastGravFlip));
  gravTimerEl.textContent = Math.ceil(untilFlip/1000);
  if(now - lastGravFlip >= gravFlipInterval){
    flipGravity(now);
  }

  updateEnemies(delta);
  update(delta);
  draw();

  statsEl.textContent = `World: ${world} | HP: ${player.hp} | Coins: ${player.coins}`;

  requestAnimationFrame(loop);
}

//

